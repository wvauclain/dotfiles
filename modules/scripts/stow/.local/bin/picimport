#!/usr/bin/env python3
import mimetypes
import os
import re
import shutil
import subprocess
import sys
import traceback
from pathlib import Path

TAGGED_DIR = "/home/will/sync/pictures/tagged"

# e.g. 2020-06-24T08:45:38
TIMESTAMP_REGEX = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})T(?P<hour>\d{2}):(?P<minute>\d{2}):(?P<second>\d{2})"

# e.g. 2020:06:24 08:45:38
EXIF_TIMESTAMP_REGEX = r"(?P<year>\d{4}):(?P<month>\d{2}):(?P<day>\d{2}) (?P<hour>\d{2}):(?P<minute>\d{2}):(?P<second>\d{2})"

# e.g. 2020-06-24 08:45:38 AM
IPHONE_TIMESTAMP_REGEX = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2}) (?P<hour>\d{2}):(?P<minute>\d{2}):(?P<second>\d{2}) (?P<TOD>(AM|PM))"

# e.g. 20200624-084538
DIRECTORY_TIMESTAMP_REGEX = r"(?P<year>\d{4})(?P<month>\d{2})(?P<day>\d{2})-(?P<hour>\d{2})(?P<minute>\d{2})(?P<second>\d{2})"

# e.g. 2020-06-24
DIRECTORY_DATE_REGEX = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"

# Regex for the filename that is aware of potential tags
TAG_AWARE_REGEX = r"^(?P<timestamp>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2} )?(?P<name>.*?)?(?P<rest>( -- .*?)?(\.[^.]+?)*?)$"


class Timestamp:
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def __str__(self):
        return "%04d-%02d-%02dT%02d:%02d:%02d" % (
            self.year,
            self.month,
            self.day,
            self.hour,
            self.minute,
            self.second,
        )

    @staticmethod
    def from_match(match: re.Match, has_tod=False):
        hour = int(match.group("hour"))
        if has_tod:
            if hour == 12:
                hour = 12 if match.group("TOD") == "PM" else 0
            else:
                hour += 12 if match.group("TOD") == "PM" else 0

        return Timestamp(
            int(match.group("year")),
            int(match.group("month")),
            int(match.group("day")),
            hour,
            int(match.group("minute")),
            int(match.group("second")),
        )

    @staticmethod
    def from_date_match(match: re.Match):
        return Timestamp(
            int(match.group("year")), int(match.group("month")), int(match.group("day")), 0, 0, 0,
        )


def get_exif_timestamp(filename):
    # Don't try to use identify on video files, it eats up gigabytes of memory
    mt, _ = mimetypes.guess_type(filename)
    if mt is None or mt.split("/")[0] != "image":
        return None

    def get_prop(prop):
        return subprocess.run(
            f'identify -format "%[exif:{prop}]" -- "{filename}" 2>/dev/null',
            shell=True,
            encoding="utf-8",
            capture_output=True,
        ).stdout

    timestamp = get_prop("DateTime") or get_prop("DateTimeOriginal") or None
    if timestamp is None:
        return None

    match = re.match(EXIF_TIMESTAMP_REGEX, timestamp)
    if not match:
        return None

    # Some files have weird EXIF timestamps
    if int(match.group("year")) == 0:
        return None

    return Timestamp.from_match(match)


def timestamp_filename(IF) -> str:
    filename = os.path.basename(IF)
    dirname = os.path.basename(os.path.dirname(IF))

    # If the input file is an image, try to get its date from the EXIF data
    if (timestamp := get_exif_timestamp(IF)) :
        return f"{timestamp} {filename}"

    # Maybe the filename already has a timestamp
    if (match := re.match(TIMESTAMP_REGEX, filename)) :
        return f"{Timestamp.from_match(match)}{filename[match.end():]}"

    # If the filename already has a timestamp but it's in a different format, use that
    # e.g. 2020-06-24 08:45:38 AM for photos from my iPhone
    if (match := re.match(IPHONE_TIMESTAMP_REGEX, filename)) :
        return f"{Timestamp.from_match(match, has_tod=True)}{filename[match.end():]}"

    # Maybe the directory has a timestamp
    # e.g. 19990328-210438 from iPhoto
    if (match := re.match(DIRECTORY_TIMESTAMP_REGEX, dirname)) :
        return f"{Timestamp.from_match(match)} {filename}"

    # or 1999-03-28 from Google photos
    if (match := re.match(DIRECTORY_DATE_REGEX, dirname)) :
        return f"{Timestamp.from_date_match(match)} {filename}"

    # Otherwise, just ask us to make an educated guess
    year = os.environ.get("YEAR", None) or input(
        "We can't detect a timestamp for this file. What year was it taken? "
    )
    if not re.match(r"\d{4}", year):
        raise ValueError(f"invalid year '{year}'")

    return f"{Timestamp(int(year), 0, 0, 0, 0, 0)} {filename}"


if __name__ == "__main__":
    for f in sys.argv[1:]:
        try:
            if not os.path.exists(f):
                raise Exception(f"file '{f}' does not exist")

            IF = os.path.realpath(f)

            timestamped_filename = timestamp_filename(IF)
            output_filename = Path(TAGGED_DIR, timestamped_filename)

            # NOTE: This makes the key assumption that the file isn't already tagged.
            i = 1
            match = re.match(TAG_AWARE_REGEX, timestamped_filename)
            while output_filename.exists():
                i = i + 1
                output_filename = output_filename.with_name(
                    f"{match.group('timestamp') or ''}{match.group('name') or ''} {i}{match.group('rest') or ''}"
                )

            shutil.copyfile(IF, output_filename)
            print(f"\033[32msuccess: \033[0m{f} ~> {output_filename}")

            # correct orientation
            mt, _ = mimetypes.guess_type(output_filename)
            if mt is not None and mt.split("/")[0] == "image":
                subprocess.run(["mogrify", "-auto-orient", output_filename])
        except Exception as e:
            print(f"\033[31merror processing {IF}: \033[0m{e}")
            traceback.print_exc()
